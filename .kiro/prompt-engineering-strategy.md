# プロンプトエンジニアリング戦略

**作成日**: 2025-12-08
**目的**: LLMシフト生成システムの段階的プロンプト分割アプローチを設計・文書化

---

## 問題の本質

### BUG-011の教訓

```
finishReason: 'MAX_TOKENS'
thoughtsTokenCount: 65535
candidatesTokenCount: 0  ← 出力トークンがゼロ
```

**根本原因**: Gemini 2.5 Flashの「思考モード」では、`maxOutputTokens`の予算が思考+出力で共有される。プロンプトが複雑になると思考トークンが増大し、出力用の予算が枯渇する。

**アンチパターン**: プロンプトを「短くする」だけでは解決しない。
- 情報量を減らすと、AIが制約を無視し始める
- 本末転倒: AI品質が低下する

---

## 現在のアーキテクチャ分析

### 2段階生成（Phase 44で実装）

```
Phase 1: generateSkeleton（骨子生成）
    ↓ skeleton（休日・夜勤パターン）
Phase 2: generateDetailedShifts（詳細生成）× N バッチ
    ↓ 完成シフト
```

**設計根拠**:
1. 複雑な問題を分割してAIの認知負荷を軽減
2. 各フェーズで異なる制約に集中できる
3. バッチ処理でトークン使用量を分散

### 現在のプロンプト構成（Phase 1）

| セクション | 目的 | トークン消費 |
|-----------|------|-------------|
| スタッフ情報 | 各スタッフの制約 | 中〜高（人数比例） |
| 期間情報 | 対象月・営業日 | 低 |
| 必要人員テーブル | シフト別必要人数 | 低 |
| 制約条件（必須） | ハードコンストレイント | 中 |
| 動的制約 | パート・連勤・人員配置 | **高**（BUG-011の原因） |
| 数学的検証 | 計算根拠 | 低 |
| 出力形式 | JSON構造定義 | 低 |
| 出力前チェック | 自己検証リスト | 低 |

---

## 段階的プロンプト分割アプローチ

### 設計原則

#### 1. 関心の分離（Separation of Concerns）

各フェーズは**1つの関心**に集中する。

```
現在:
Phase 1: 骨子生成 + 全制約チェック ← 認知負荷が高い

提案:
Phase 1a: 休日パターン生成（連勤制約のみ）
Phase 1b: 人員配置検証（人員制約のみ）
Phase 2: 詳細シフト割当
```

#### 2. 累積コンテキスト（Cumulative Context）

後続フェーズは前フェーズの結果を受け取り、追加の情報のみを処理する。

```
Phase 1a出力: skeleton_draft（休日パターン案）
    ↓ 入力として渡す
Phase 1b: skeleton_draftを検証・調整
    ↓ 入力として渡す
Phase 2: 詳細生成
```

#### 3. 検証と修正の分離

生成と検証を別フェーズにすることで、AIの負荷を軽減。

```
生成フェーズ: 制約を意識しつつ生成
検証フェーズ: 制約違反を検出し修正案を提案
```

---

## 提案アーキテクチャ

### オプションA: 3段階生成（推奨）

```
Phase 1a: generateRestDayPattern（休日パターン生成）
  - 入力: スタッフリスト、連勤制約
  - 出力: 各スタッフの休日候補

Phase 1b: validateAndAdjustStaffing（人員配置検証・調整）
  - 入力: 休日パターン + 人員要件
  - 出力: 調整済み骨子

Phase 2: generateDetailedShifts（詳細生成）
  - 入力: 確定骨子 + シフト種別要件
  - 出力: 完成シフト
```

**メリット**:
- 各フェーズのプロンプトサイズが小さくなる
- 思考トークン消費が分散される
- 問題発生時の切り分けが容易

**デメリット**:
- API呼び出し回数が増加（コスト・レイテンシ）
- フェーズ間のデータ整合性管理が必要

### オプションB: 動的制約の遅延注入

```
Phase 1: generateSkeleton（現行）
  - 動的制約を含めず、基本ルールのみ
  - 出力: 初期骨子

Phase 1.5: validateSkeleton（新設）
  - 入力: 初期骨子 + 全動的制約
  - AIに「違反を検出して修正」させる
  - 出力: 修正済み骨子

Phase 2: generateDetailedShifts（現行）
```

**メリット**:
- 現行アーキテクチャへの変更が最小限
- 検証フェーズで制約を詳細に説明できる

**デメリット**:
- 修正が大規模な場合、反復が必要になる可能性

### オプションC: ハイブリッドアプローチ（中長期）

```
LLMフェーズ: 休日パターン・基本構造を生成
    ↓
制約ソルバー: 数学的に人員配置を最適化
    ↓
LLMフェーズ: 詳細シフト割当
```

**メリット**:
- 数学的保証が得られる（人員不足ゼロ）
- LLMの強み（柔軟性）とソルバーの強み（正確性）を組み合わせ

**デメリット**:
- 実装コストが高い
- 追加の依存関係（OR-Tools等）

---

## 短期的対応（Phase 49修正）

### 現実的なアプローチ

BUG-011の教訓を踏まえ、**オプションB（動的制約の遅延注入）**を短期的に採用する。

#### 実装案

```typescript
// 現在のbuildSkeletonPromptを軽量化
function buildSkeletonPrompt(...): string {
  // 動的制約を含めない
  // 基本ルールのみで骨子を生成
}

// 新設: 骨子検証フェーズ
async function validateSkeleton(
  skeleton: ScheduleSkeleton,
  staffList: Staff[],
  requirements: ShiftRequirement
): Promise<ScheduleSkeleton> {
  // 動的制約を使って違反を検出・修正
}
```

ただし、**まず現在の修正（BUG-011 fix）をテストして効果を確認する**ことが先決。

---

## プロンプト設計ベストプラクティス

### 1. 情報密度 vs 明示性

| アプローチ | トークン効率 | AI理解度 |
|-----------|------------|---------|
| 高密度（表形式） | 高 | 中〜低 |
| 明示的（箇条書き） | 低 | 高 |
| ハイブリッド | 中 | 中〜高 |

**推奨**: 重要な制約は明示的に、背景情報は高密度で。

### 2. 指示の優先順位付け

```markdown
## 必須条件（厳守） ← AIはここを最優先
1. ...

## 努力目標 ← 可能な範囲で
- ...
```

### 3. 自己検証の組み込み

```markdown
# 出力前チェック
□ 全スタッフ分の出力があるか
□ 日曜日が休日に含まれているか
□ 連続勤務が5日を超えていないか
```

AIに自己チェックを促すことで、違反率が低下する傾向がある。

### 4. ネガティブ指示の活用

```markdown
**⚠️ 休日を入れすぎないこと！** ← 明示的な禁止
```

LLMは「やるべきこと」より「やってはいけないこと」の方が従いやすい場合がある。

---

## トークン予算管理

### Gemini 2.5 Flash設定

| パラメータ | 値 | 説明 |
|-----------|-----|-----|
| maxOutputTokens | 65536 | 思考+出力の合計予算 |
| thinkingBudget | 16384 | 思考トークンの上限 |
| 残り | 49152 | 出力用トークン |

### スタッフ数別の推奨設定

| スタッフ数 | thinkingBudget | 根拠 |
|-----------|----------------|------|
| 1-5名 | 8192 | 低複雑度 |
| 6-10名 | 16384 | 中複雑度 |
| 11-15名 | 16384 | 高複雑度（現在の設定） |
| 16名以上 | 16384 | 上限固定（3段階化を検討） |

### プロンプトサイズ管理

```typescript
function estimatePromptTokens(prompt: string): number {
  // 日本語: 1文字 ≒ 1-2トークン
  // 英語: 4文字 ≒ 1トークン
  return Math.ceil(prompt.length * 1.5);  // 概算
}

// 閾値を超えたら警告
const PROMPT_TOKEN_WARNING_THRESHOLD = 8000;
```

---

## 次のステップ

### 短期（Phase 49-50）

1. [x] BUG-011修正をデプロイ
2. [ ] 本番環境でテスト
3. [ ] 結果に基づき追加調整

### 中期（Phase 51-55）

1. [ ] オプションBの実装検討（validateSkeletonフェーズ追加）
2. [ ] プロンプトトークン計測の自動化
3. [ ] A/Bテスト基盤の構築

### 長期

1. [ ] オプションCの検討（制約ソルバー統合）
2. [ ] Fine-tuning用データ収集

---

## 関連ドキュメント

- [AI品質改善ガイド](./ai-quality-improvement-guide.md)
- [Phase 49ドキュメント](../docs/phase49-staffing-constraints.html)
- [BUG-011修正記録](./bugfix-max-tokens-2025-12-08.md)
- [CLAUDE.md](../CLAUDE.md) - プロジェクトルール

---

**作成者**: Claude Opus 4.5
**最終更新**: 2025-12-08

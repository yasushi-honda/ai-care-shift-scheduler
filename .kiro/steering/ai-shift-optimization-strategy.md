# AI Shift Generation Optimization Strategy

**作成日**: 2025-12-30
**ステータス**: 戦略策定中

---

## 1. 問題定義

### 1.1 現象
AI生成シフトのスコアが不安定（0-28の範囲でばらつき）

### 1.2 データ収集結果

| テスト# | overallScore | fulfillmentRate | violations | 早番 | 日勤 | 遅番 | 休 |
|---------|--------------|-----------------|------------|------|------|------|-----|
| 1 | 28 | 95% | 6 | 55 | 74 | 35 | 208 |
| 2 | 0 | 93% | 10 | 50 | 71 | 35 | 216 |
| 3 | 16 | 93% | 7 | 55 | 74 | 35 | 190 |
| 4 | 0 | 88% | 16 | 55 | 64 | 28 | 225 |

### 1.3 要件（27営業日基準）
| シフト | 必要/日 | 月間必要 | 実績範囲 | 過不足 |
|--------|---------|----------|----------|--------|
| 早番 | 2 | 54 | 50-55 | -4〜+1 |
| 日勤 | 2 | 54 | 64-74 | +10〜+20 |
| 遅番 | 1 | 27 | 28-35 | +1〜+8 |

### 1.4 根本原因分析

```
問題: 日単位の配置バランスが不安定
  ├─ 原因1: バッチ処理の独立性
  │    └─ 各バッチが他バッチの結果を知らない
  ├─ 原因2: AIの暗黙のバイアス
  │    └─ 「日勤」を安全なデフォルトとして選択する傾向
  ├─ 原因3: フィードバック機構の欠如
  │    └─ 生成後の検証・修正ループがない
  └─ 原因4: グローバル最適化の欠如
       └─ ローカル（スタッフ単位）最適化のみ
```

---

## 2. MoE（Mixture of Experts）分析

### 2.1 AI/MLアーキテクチャ専門家

**診断**: 現在のPhase 2バッチ処理は「協調問題」を解決できていない

**提案**:
1. 逐次制約伝播: バッチ間で累積カウントを渡す
2. 後処理リバランス: 全バッチ完了後にシフトを交換
3. 単一パス生成: コンテキスト制限内で全員同時生成
4. 制約ベースサンプリング: 複数候補から最適を選択

### 2.2 オペレーションズリサーチ専門家

**診断**: シフトスケジューリング最適化問題として、ローカル最適化ではなくグローバル最適化が必要

**数学的定式化**:
```
変数: x[s,d,t] = スタッフsが日dにシフトtを担当するか (0/1)

制約:
  - Σ_s x[s,d,t] >= requirement[t]  ∀d,t （日別必要人数）
  - x[s,d,t] = 0 if d is rest day for s （休日制約）
  - Σ_t x[s,d,t] <= 1  ∀s,d （1日1シフト）
```

**提案**:
1. 整数線形計画法（ILP）: 最適解保証だが計算コスト高
2. 制約充足: 実行可能解を高速に発見
3. ハイブリッド: AI初期解 + ILP最適化

### 2.3 プロンプトエンジニアリング専門家

**診断**:
- 各バッチが他バッチの状態を知らない
- 「バランス」指示が曖昧
- フィードバック機構なし

**提案**:
1. クォータベースプロンプト: 「このバッチはX早番、Y日勤、Z遅番を生成せよ」
2. 例示駆動: バランスの取れた例を提示
3. Chain-of-Thought: まず配分計算、次に割当
4. 自己検証: AI自身に出力チェックを依頼

### 2.4 ソフトウェアエンジニアリング専門家

**診断**: フィードバックループと状態共有が欠如

**現在のフロー**:
```
Request → Phase1 → Phase2(バッチ) → 評価 → Response
```

**提案フロー**:
```
Request → Phase1 → Phase2 → 評価 →
  IF score < threshold THEN
    Rebalance OR 特定バッチ再生成
  → Response
```

### 2.5 データアナリスト

**パターン分析**:
- 日勤: 常に過剰（+10〜+20）
- 早番: 不足傾向（-4〜+1）
- 遅番: 変動大（+1〜+8）
- Batch2（小規模）はBatch1より配分が悪い

**仮説**: AIは「日勤」を不確実時のデフォルトとして使用

---

## 3. 戦略オプション

### 3.1 戦略A: 後処理リバランス
**リスク**: 低 | **影響**: 中 | **実装コスト**: 低

```typescript
// Phase 2完了後に実行
function rebalanceShifts(schedules, requirements) {
  for each day:
    if (早番不足 && 日勤過剰):
      swap one 日勤 → 早番
    if (遅番不足 && 日勤過剰):
      swap one 日勤 → 遅番
  return rebalanced
}
```

**メリット**:
- 既存コードへの影響が最小
- 休日は変更しない
- 予測可能な結果

**デメリット**:
- スタッフ希望を無視する可能性
- 最適解ではない

### 3.2 戦略B: クォータベースバッチ生成
**リスク**: 中 | **影響**: 高 | **実装コスト**: 中

```typescript
// バッチ生成時にクォータを計算・伝達
function generateWithQuotas(batch, remainingQuotas) {
  const batchQuota = calculateBatchQuota(batch, remainingQuotas);
  const prompt = buildPromptWithQuota(batch, batchQuota);
  const result = await generateWithAI(prompt);
  return { result, usedQuotas };
}
```

**メリット**:
- AIに明確な目標を与える
- バッチ間の整合性向上

**デメリット**:
- プロンプト複雑化
- AIが厳密にクォータを守らない可能性

### 3.3 戦略C: ハイブリッドAI+最適化
**リスク**: 高 | **影響**: 最高 | **実装コスト**: 高

```typescript
// AI生成 → 最適化ソルバー
async function hybridGeneration() {
  const aiSchedule = await generateWithAI();
  const optimizedSchedule = await optimizeWithSolver(aiSchedule, constraints);
  return optimizedSchedule;
}
```

**メリット**:
- 最適解に近い結果
- スケーラブル

**デメリット**:
- 外部ライブラリ依存
- 実装複雑

### 3.4 戦略D: スコアベース再生成
**リスク**: 中 | **影響**: 中 | **実装コスト**: 低

```typescript
// スコアが閾値以下なら再生成
async function generateWithRetry(maxRetries = 3, minScore = 50) {
  for (let i = 0; i < maxRetries; i++) {
    const result = await generateShift();
    if (result.overallScore >= minScore) return result;
  }
  return bestResultSoFar;
}
```

**メリット**:
- シンプル
- 既存コードへの影響小

**デメリット**:
- コスト増（複数回AI呼び出し）
- 保証なし

---

## 4. 推奨戦略

### 4.1 フェーズ1: 後処理リバランス（戦略A）
**理由**: 最小リスクで即効性あり

### 4.2 フェーズ2: クォータベース（戦略B）
**条件**: フェーズ1で目標未達の場合

### 4.3 フェーズ3: ハイブリッド（戦略C）
**条件**: 高精度が必須の場合

---

## 5. 成功基準

| 指標 | 現状 | 目標（Phase1） | 目標（最終） |
|------|------|----------------|--------------|
| overallScore | 0-28 | 40+ | 70+ |
| violationCount | 6-16 | <5 | <2 |
| fulfillmentRate | 88-95% | 95%+ | 98%+ |
| 安定性 | 低 | 中 | 高 |

---

## 6. 実装計画

### Step 1: リバランス関数の設計・実装
### Step 2: 単体テスト作成
### Step 3: 統合テスト
### Step 4: 本番デプロイ・検証
### Step 5: イテレーション

---

## 7. 次のアクション

1. [ ] リバランス関数の詳細設計
2. [ ] 実装
3. [ ] テスト
4. [ ] デプロイ
5. [ ] 検証
